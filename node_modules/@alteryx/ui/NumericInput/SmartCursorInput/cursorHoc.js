"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _keycodeJs = require("keycode-js");

var _lodash = require("lodash");

var _utils = require("../../utils");

var _constants = require("./constants");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var setRef = function setRef(ref, node) {
  if (typeof ref === 'function') {
    ref(node);
  } else if (ref) {
    ref.current = node; // eslint-disable-line no-param-reassign
  }
};

var noop = function noop() {
  return undefined;
};

function cursorHoc(InputComponent) {
  var CursorHoc = /*#__PURE__*/function (_React$Component) {
    (0, _inherits2.default)(CursorHoc, _React$Component);

    var _super = _createSuper(CursorHoc);

    function CursorHoc() {
      var _this;

      (0, _classCallCheck2.default)(this, CursorHoc);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));
      _this.undoes = false;
      _this.inserts = [];
      _this.predictedValue = null;
      _this.cursorPosition = 0;
      _this.inputRef = /*#__PURE__*/(0, _react.createRef)();
      _this.lastPressed = null;

      _this.setNewPosition = function () {
        var pos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.cursorPosition;

        if (_this.inputRef && _this.inputRef.current && _this.inputRef.current.setSelectionRange) {
          _this.inputRef.current.setSelectionRange(pos, pos);
        }
      };

      _this.handleBlur = function (event) {
        var onBlur = _this.props.onBlur;

        _this.saveCursorPosition();

        onBlur(event);
      };

      _this.handleClick = function (event) {
        var onClick = _this.props.onClick;

        _this.saveCursorPosition();

        onClick(event);
      };

      _this.predictValue = function (value, key) {
        var _this$inputRef$curren = _this.inputRef.current,
            selectionStart = _this$inputRef$curren.selectionStart,
            selectionEnd = _this$inputRef$curren.selectionEnd;
        var valueStr = value.toString();

        if (!key || key.length !== 1) {
          _this.predictedValue = null;
          return;
        } // Concat part [start,selectionStart] + entered char + [selectionEnd, end]


        _this.predictedValue = "".concat(valueStr.substr(0, selectionStart)).concat(key).concat(valueStr.substr(selectionEnd));
      };

      _this.validatePredictedValue = function () {
        var _assertThisInitialize = (0, _assertThisInitialized2.default)(_this),
            predictedValue = _assertThisInitialize.predictedValue;

        var validator = _this.props.validator; // Skip validation if next value not predicted

        if (!predictedValue) {
          return true;
        } // Skip validation if validator func not specified


        if (validator === noop) {
          return true;
        }

        return validator(_this.predictedValue);
      };

      _this.historyUpdate = function (value) {
        var _assertThisInitialize2 = (0, _assertThisInitialized2.default)(_this),
            cursorPosition = _assertThisInitialize2.cursorPosition,
            inserts = _assertThisInitialize2.inserts; // ignore, if changed caused by undo operation


        if (!_this.undoes) {
          inserts.push({
            cursorPosition: cursorPosition,
            value: value
          });
        } // Unmark this value update as undo operation


        _this.undoes = false;
      };

      _this.historyRestore = function () {
        var onChange = _this.props.onChange;
        var insert = (0, _lodash.last)(_this.inserts);

        if (!(0, _lodash.isEmpty)(insert)) {
          var _this$inserts$pop = _this.inserts.pop(),
              value = _this$inserts$pop.value; // Mark this change as undo


          _this.undoes = true;
          onChange({
            target: {
              value: value.toString()
            },
            preventDefault: noop
          });
        }
      };

      _this.handleKeyDown = function (event) {
        var _this$props = _this.props,
            onKeyDown = _this$props.onKeyDown,
            value = _this$props.value;
        var key = event.key,
            keyCode = event.keyCode,
            shiftKey = event.shiftKey,
            metaKey = event.metaKey,
            ctrlKey = event.ctrlKey;

        _this.saveCursorPosition();

        _this.lastPressed = keyCode;
        var isMetaPressed = metaKey || ctrlKey || shiftKey;
        var isCtrlPressed = ctrlKey || metaKey;
        var isMeta = _constants.META_KEYS.includes(keyCode) || isMetaPressed;

        var isClipboard = isMetaPressed && _constants.CLIPBOARD_KEYS.includes(keyCode);

        var isUndo = isCtrlPressed && _constants.UNDO_KEYS.includes(keyCode); // Adding this check so that tabbing works correctly in Safari without also firing the onBlur event twice in other browsers.


        if (window.navigator.userAgent.includes('Safari') && !window.navigator.userAgent.includes('Chrome') && key === 'Tab' || key === 'Tab' && shiftKey) {
          _this.handleBlur(event);

          return;
        }

        if (isUndo) {
          // Handle CMD+Z by own
          _this.historyRestore(); // Prevent any browser CMD+Z behaviour


          event.preventDefault();
          return;
        }

        if (!isMeta && !isClipboard) {
          _this.predictValue(value, key); // Prevent any browser behaviour if predicted value not valid


          if (!_this.validatePredictedValue()) {
            event.preventDefault();
          } // save last caret position if component won't be updated


          setTimeout(_this.setNewPosition, 0);
        }

        onKeyDown(event);
      };

      _this.handleKeyUp = function (event) {
        var onKeyUp = _this.props.onKeyUp;

        _this.saveCursorPosition();

        onKeyUp(event);
      };

      _this.saveCursorPosition = function () {
        _this.cursorPosition = Math.max(0, _this.inputRef.current.selectionEnd);
      };

      return _this;
    }

    (0, _createClass2.default)(CursorHoc, [{
      key: "componentDidUpdate",
      value: function componentDidUpdate(_ref) {
        var prevValue = _ref.value;
        var value = this.props.value;
        var valueStr = value === undefined ? '0' : value.toString();
        var prevValueStr = prevValue === undefined ? '0' : prevValue.toString();
        var valueDiff;
        var pointDiff = 0;

        if (valueStr === prevValueStr) {
          return;
        }

        valueDiff = valueStr.length - prevValueStr.length;
        /*
          Does't change cursor position, if DELETE pressed and value decreased
         */

        if (valueDiff < 0 && this.lastPressed === _keycodeJs.KEY_DELETE) {
          this.setNewPosition();
          return;
        }
        /*
          Count diff at predicted value, if length of value does't change
         */


        if (!valueDiff && this.predictedValue) {
          var currentPoint = valueStr.indexOf('.');
          var predictedPoint = this.predictedValue.indexOf('.');
          valueDiff = this.predictedValue.length - valueStr.length;
          /*
            If current cursor position same as point and old difference by one
           */

          if (this.cursorPosition === currentPoint && this.cursorPosition + 1 === predictedPoint) {
            pointDiff = 1;
          }
        }

        var pos = Math.max(0, this.cursorPosition + valueDiff + pointDiff);
        this.setNewPosition(pos);
        this.cursorPosition = pos;
        this.predictedValue = null;
        this.historyUpdate(prevValue);
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;

        var disallowedProps = ['validator'];
        var filteredProps = (0, _utils.filterProps)(this.props, disallowedProps);
        var _inputRef = filteredProps.inputRef,
            restProps = (0, _objectWithoutProperties2.default)(filteredProps, ["inputRef"]);
        return /*#__PURE__*/_react.default.createElement(InputComponent // TODO: Verify it's actually bad to pass validator into InputComponent and remove this filter if not.
        , (0, _extends2.default)({}, restProps, {
          inputRef: function inputRef(node) {
            setRef(_this2.inputRef, node);
            setRef(_inputRef, node);
          },
          onBlur: this.handleBlur,
          onClick: this.handleClick,
          onFocus: function onFocus() {
            return _this2.setNewPosition();
          },
          onKeyDown: this.handleKeyDown,
          onKeyUp: this.handleKeyUp
        }));
      }
    }]);
    return CursorHoc;
  }(_react.default.Component);

  CursorHoc.propTypes = process.env.NODE_ENV !== "production" ? {
    inputRef: _propTypes.default.func,
    onBlur: _propTypes.default.func,
    onChange: _propTypes.default.func,
    onClick: _propTypes.default.func,
    onKeyDown: _propTypes.default.func,
    onKeyUp: _propTypes.default.func,
    validator: _propTypes.default.func,
    value: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string]).isRequired
  } : {};
  CursorHoc.defaultProps = {
    inputRef: undefined,
    onBlur: noop,
    onChange: noop,
    onClick: noop,
    onKeyDown: noop,
    onKeyUp: noop,
    validator: noop
  };
  return CursorHoc;
}

var _default = cursorHoc;
exports.default = _default;